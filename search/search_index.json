{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Build your own Serverless Food Delivery App in 3 hours! Goal: Leverage AWS Serverless services to build a simple food delivery app in less than 3 hours! In this workshop, we will understand how easy & quick it is to build real-world applications using Serverless on AWS and understand the various services that can be leveraged. The application will present users with a React user interface for ordering food items. The interface on the backend with RESTful and WebSocket services will accept the request, and find and dispatch food to the requester\u2019s location. The application will also provide facilities for users to register with the service and log in before ordering food. Lab steps/Documentation link - https://srushithr.github.io/acd2022-serverless-workshop/","title":"Build your own Serverless Food Delivery App in 3 hours!"},{"location":"#build-your-own-serverless-food-delivery-app-in-3-hours","text":"Goal: Leverage AWS Serverless services to build a simple food delivery app in less than 3 hours! In this workshop, we will understand how easy & quick it is to build real-world applications using Serverless on AWS and understand the various services that can be leveraged. The application will present users with a React user interface for ordering food items. The interface on the backend with RESTful and WebSocket services will accept the request, and find and dispatch food to the requester\u2019s location. The application will also provide facilities for users to register with the service and log in before ordering food. Lab steps/Documentation link - https://srushithr.github.io/acd2022-serverless-workshop/","title":"Build your own Serverless Food Delivery App in 3 hours!"},{"location":"EventBridge/","text":"Setting up EventBridge EventBridge has become an integral part of Serverless applications. In this section we will see how to create Event bus, Event Rules and integrate them with the following microservices: restaurants_service - this microservice simulates the functionality of a restaurant, accepts orders and publishes a message ( Order Accepted ) to the event bus, which will be picked up the delivery and notification microservices delivery service - this microservice simulates the functionality of delivering the order to the customer's location, and publishes a message ( Order Delivered ) to the event bus, which will be picked up the notification microservice notifications_service - this microservice will help in sending WebSocket messages to the client using the API Gateway client of boto3 Create the above 3 lambda functions, which will be integrated with event rules in the following steps Steps to create an Event Bus Navigate to the EventBridge service on the AWS console and perform the following steps to create an event bus: Select Event buses on the left nav bar Click on Create event bus to create a new event bus and provide a name for the same. Ex food-app-bus and leave the defaults for the rest of the things Steps to create Event Rules As a part of our application, we will be creating 3 rules: OrderPlacedRule - this rule will trigger the restaurants microservice to notify the restaurant that an order has been placed and the restaurant needs to accept and process the same. OrderAcceptedRule - this rule will trigger the delivery microservice to start the delivery partner assignment and the delivery process. It will also trigger the notifications microservice to deliver the Order Accepted message to the client OrderDeliveredRule - this rule will trigger the notifications microservice to delivery Order Delivered message to the client Navigate to the Event Rules section on the left nav bar of the EventBridge console and perform the following steps to create event rules: Select the event bus that was created in the previous section and click on Create Rule to create the following rules: Step 1 (Define rule detail) - Provide a name for the rule, order_placed and click on Next Step 2 (Build event pattern): Select Other as the Event Source to indicate that custom events will be used to push messages to the bus Add the following JSON to the Event Pattern section and click on Next : json { \"detail-type\": [\"order_placed\"], \"source\": [\"custom.food_app\"] } Step 3 (Select Targets): Select AWS service as the target and chose Lambda function from the dropdown list Select the restaurants_service lambda function that was created above and click on Next Step 4 (Configure Tags) - you can provide any tags if needed or can skip and click on Next Step 5 (Review and Create) - review all the configurations created in the previous steps and click on Create Rule Repeat the above steps to create 2 more rules: Order Accepted Rule with the following config: Event Pattern : { \"detail-type\": [\"order_accepted\"], \"source\": [\"custom.food_app\"] } Two target lambda functions - delivery_service and notification_service Order Delivered Rule with the following config: Event Pattern : { \"detail-type\": [\"order_delivered\"], \"source\": [\"custom.food_app\"] } Target lambda - notifications_service Update Lambda Function Config Create the following 2 environment variables in the Configuration section: WEBSOCKET_DOMAIN - the websocket domain created as a part of the WebSockets section EVENT_BUS_NAME - the name of the event bus created in the above step Update the lambda function's IAM role to provide the following permissions by navigating to the IAM console, selecting the specific lambda's role and editing the policy and clicking on Add additional permissions at every following step: Select EventBridge , select all actions and all resources. This is to publish messages to the event bus so that other microservices can pick it up and proceed further Select DynamoDB , select all actions and all resources. This is to update the DynamoDB table with the appropriate order status Select API Gateway , select all actions and all resources. This is used to send WebSocket messages back to the client Or, you can simply update the IAM policy with the following JSON: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"dynamodb:PutItem\", \"dynamodb:DeleteItem\", \"dynamodb:GetItem\", \"dynamodb:Query\", \"dynamodb:UpdateItem\" ], \"Resource\": \"*\" }, { \"Sid\": \"VisualEditor1\", \"Effect\": \"Allow\", \"Action\": [ \"logs:CreateLogStream\", \"execute-api:ManageConnections\", \"logs:CreateLogGroup\" ], \"Resource\": \"*\" }, { \"Sid\": \"VisualEditor2\", \"Effect\": \"Allow\", \"Action\": \"logs:PutLogEvents\", \"Resource\": \"*\" }, { \"Sid\": \"VisualEditor3\", \"Effect\": \"Allow\", \"Action\": \"events:*\", \"Resource\": \"*\" } ] } Testing Navigate to the Event Bus on the left nav bar and click on Send Events and: Select the event bus created above Add the event source - custom.food_app Add the detail type as order_placed Add the following event detail: { \"order_id\": \"0ff5e0c8-7c95-49be-ac84-771d47e1d92a\", \"order_status\": \"order_placed\", \"user_id\": \"68a0f215-8453-45be-a418-5b0b1c94b456\" } Deploy using Serverless Framework If you want to deploy all the resources for the EventBridge segment, please use the following resource: cd EventBridgeSetup serverless deploy --region eu-west-2 And the above command would create the following services: 4 lambda functions to simulate 4 microservices - orders, restaurants, delivery, notifications Event bus 3 Event rules Permission for EventBridge to trigger the targets","title":"EventBridge"},{"location":"EventBridge/#setting-up-eventbridge","text":"EventBridge has become an integral part of Serverless applications. In this section we will see how to create Event bus, Event Rules and integrate them with the following microservices: restaurants_service - this microservice simulates the functionality of a restaurant, accepts orders and publishes a message ( Order Accepted ) to the event bus, which will be picked up the delivery and notification microservices delivery service - this microservice simulates the functionality of delivering the order to the customer's location, and publishes a message ( Order Delivered ) to the event bus, which will be picked up the notification microservice notifications_service - this microservice will help in sending WebSocket messages to the client using the API Gateway client of boto3 Create the above 3 lambda functions, which will be integrated with event rules in the following steps","title":"Setting up EventBridge"},{"location":"EventBridge/#steps-to-create-an-event-bus","text":"Navigate to the EventBridge service on the AWS console and perform the following steps to create an event bus: Select Event buses on the left nav bar Click on Create event bus to create a new event bus and provide a name for the same. Ex food-app-bus and leave the defaults for the rest of the things","title":"Steps to create an Event Bus"},{"location":"EventBridge/#steps-to-create-event-rules","text":"As a part of our application, we will be creating 3 rules: OrderPlacedRule - this rule will trigger the restaurants microservice to notify the restaurant that an order has been placed and the restaurant needs to accept and process the same. OrderAcceptedRule - this rule will trigger the delivery microservice to start the delivery partner assignment and the delivery process. It will also trigger the notifications microservice to deliver the Order Accepted message to the client OrderDeliveredRule - this rule will trigger the notifications microservice to delivery Order Delivered message to the client Navigate to the Event Rules section on the left nav bar of the EventBridge console and perform the following steps to create event rules: Select the event bus that was created in the previous section and click on Create Rule to create the following rules: Step 1 (Define rule detail) - Provide a name for the rule, order_placed and click on Next Step 2 (Build event pattern): Select Other as the Event Source to indicate that custom events will be used to push messages to the bus Add the following JSON to the Event Pattern section and click on Next : json { \"detail-type\": [\"order_placed\"], \"source\": [\"custom.food_app\"] } Step 3 (Select Targets): Select AWS service as the target and chose Lambda function from the dropdown list Select the restaurants_service lambda function that was created above and click on Next Step 4 (Configure Tags) - you can provide any tags if needed or can skip and click on Next Step 5 (Review and Create) - review all the configurations created in the previous steps and click on Create Rule Repeat the above steps to create 2 more rules: Order Accepted Rule with the following config: Event Pattern : { \"detail-type\": [\"order_accepted\"], \"source\": [\"custom.food_app\"] } Two target lambda functions - delivery_service and notification_service Order Delivered Rule with the following config: Event Pattern : { \"detail-type\": [\"order_delivered\"], \"source\": [\"custom.food_app\"] } Target lambda - notifications_service","title":"Steps to create Event Rules"},{"location":"EventBridge/#update-lambda-function-config","text":"Create the following 2 environment variables in the Configuration section: WEBSOCKET_DOMAIN - the websocket domain created as a part of the WebSockets section EVENT_BUS_NAME - the name of the event bus created in the above step Update the lambda function's IAM role to provide the following permissions by navigating to the IAM console, selecting the specific lambda's role and editing the policy and clicking on Add additional permissions at every following step: Select EventBridge , select all actions and all resources. This is to publish messages to the event bus so that other microservices can pick it up and proceed further Select DynamoDB , select all actions and all resources. This is to update the DynamoDB table with the appropriate order status Select API Gateway , select all actions and all resources. This is used to send WebSocket messages back to the client Or, you can simply update the IAM policy with the following JSON: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Sid\": \"VisualEditor0\", \"Effect\": \"Allow\", \"Action\": [ \"dynamodb:PutItem\", \"dynamodb:DeleteItem\", \"dynamodb:GetItem\", \"dynamodb:Query\", \"dynamodb:UpdateItem\" ], \"Resource\": \"*\" }, { \"Sid\": \"VisualEditor1\", \"Effect\": \"Allow\", \"Action\": [ \"logs:CreateLogStream\", \"execute-api:ManageConnections\", \"logs:CreateLogGroup\" ], \"Resource\": \"*\" }, { \"Sid\": \"VisualEditor2\", \"Effect\": \"Allow\", \"Action\": \"logs:PutLogEvents\", \"Resource\": \"*\" }, { \"Sid\": \"VisualEditor3\", \"Effect\": \"Allow\", \"Action\": \"events:*\", \"Resource\": \"*\" } ] }","title":"Update Lambda Function Config"},{"location":"EventBridge/#testing","text":"Navigate to the Event Bus on the left nav bar and click on Send Events and: Select the event bus created above Add the event source - custom.food_app Add the detail type as order_placed Add the following event detail: { \"order_id\": \"0ff5e0c8-7c95-49be-ac84-771d47e1d92a\", \"order_status\": \"order_placed\", \"user_id\": \"68a0f215-8453-45be-a418-5b0b1c94b456\" }","title":"Testing"},{"location":"EventBridge/#deploy-using-serverless-framework","text":"If you want to deploy all the resources for the EventBridge segment, please use the following resource: cd EventBridgeSetup serverless deploy --region eu-west-2 And the above command would create the following services: 4 lambda functions to simulate 4 microservices - orders, restaurants, delivery, notifications Event bus 3 Event rules Permission for EventBridge to trigger the targets","title":"Deploy using Serverless Framework"},{"location":"WebSockets/","text":"Real Time Communication Using WebSockets The application leverages WebSockets to create a tunnel between the UI/Client and the backend, using which messages can be transmitted by both parties, to both parties. This eliminates the need to refresh a page every time an update is received to the backend. Architecture Details The notification service leverages the following AWS services: Amazon APIGateway\u2019s WebSocket API Lambda functions for connection management and message publishing DynamoDB to store & maintain all connections. The table has the following index configuration: connection_id as the partition key UserIdIndex as the Global Secondary Index with user_id as the partition key. This index is used to fetch the list of connections for a particular user_id Understanding Notifications Service The notifications service consists of 2 parts: Connection management Publishing messages to the interested connections We can create routes for a WebSocket API (synonymous with API routes in REST API) and the RTC handler has the following routes: $connect - This route is called when the client is requesting to connect with the backend. The user_id is passed as a query param to be stored in the connection management DynamoDB table $disconnect - This route is called when the client disconnects from the backend. This is also called when the user navigates to a different page other than the scheduling page or when the tab is closed $default - This is the default route, called when the request is for a route that is not configured Connection Management The client calls the WebSocket API with the $connect route and with the user_id passed in the query param. API Gateway will call the RTC Handler lambda with the $connect route with the connection_id . The lambda function stores the following information in DynamoDB: { \"connection_id\": \"M9aA1e3uvHcCH1A=\", \"user_id\": \"8a938091-7b1b-b753-017b-3f25f7540509\" } The client calls the $disconnect flow when the user navigates to a different page or the tab is closed. The lambda function just deletes the connectionId from the DynamoDB data store Sending messages to the client Messages can be sent to the connected clients using the WebSocket\u2019s connection URL and passing the connection_id to whom the message needs to be sent. The publisher lambda does the following: 1. Fetches the connection_id for the corresponding user_id 2. send the message using the AWS SDK for API Gateway, which leverages the connection_id and automatically sends the message Factors to consider while using WebSockets Cost - Websockets have a few factors considered for the pricing: We are charged for every minute a connection is kept alive The number of messages sent in the connection The connection timeouts, quotas, and limits: 500 connections per second Message Payload size: 128 KB Idle Connection Timeout - 10 minutes Connection duration for WebSocket API - 2 hours Steps to create the Notifications service The notifications service will be composed of 2 lambda functions: 1. event_handler - this lambda function is responsible for handling the connections - creating and deleting them from the connection-management DynamoDB table 2. message_publisher - this lambda function is responsible for sending messages to the client using the connection_id by leveraging the API Create the above 2 lambda functions using the console Steps to create a WebSocket API Navigate to the API Gateway service on the AWS console and click on Create API , select Build under the WebSocket API section and provide the following details in each section: Step 1 (API Details) API Name - Name of the API we want to create. Ex: awesome-food-app Route selection expression - API Gateway uses the route selection expression to determine which route to invoke when a client sends a message. You can provide the standard $request.body.action Step 2 (Add Routes) - configure the list of routes you want to add for the API. You can just add the Predefined Routes : $connect - triggered when a client connects to your API $disconnect - triggered when either the server or the client closes the connection $default - triggered if the route selection expression can't be evaluated against the message or if no matching route is found and click on Next Step 3 (Attach Integrations) - this step is used to configure the target for the routes configured in the previous section. For every route configured, select the Integration Type as Lambda and provide the name of the notifications service lambda function name created above Step 4 (Add Stages) - configure stage name for your WebSocket API. Ex: dev Step 5 (Review & Create) - review all the configuration details and click on Create and Deploy if everything looks good Steps to create the Connection Management DynamoDB table Navigate to the DynamoDB service on the AWS console and go to the Tables section and click on Create Table . Provide the table name connection-manager with connection_id as the partition key Select the default settings and click on Create Create a Global Secondary Index (GSI) by getting inside the specific table in the Tables/Update settings page: navigate to the Indexes tab. Click on Create Index Provide user_id and UserIdIndex as the index name Leave the rest of the settings as is and click on Create Index Update Lambda function settings Update the IAM policy: Update the event_handler and message_publisher lambda function's permissions to provide access to DynamoDB (for connection management) and API Gateway to publish messages. You can update the lambda function's IAM role's policy to: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"logs:CreateLogStream\", \"logs:CreateLogGroup\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" }, { \"Action\": [ \"logs:PutLogEvents\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" }, { \"Action\": [ \"dynamodb:Query\", \"dynamodb:GetItem\", \"dynamodb:PutItem\", \"dynamodb:UpdateItem\", \"dynamodb:DeleteItem\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" }, { \"Action\": [ \"execute-api:*\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" } ] } Update the environment variables - Create an environment variable WEBSOCKET_DOMAIN for the lambda function and value can be fetched from the WebSocket API created in the above step. Ex: g107cr37nf.execute-api.eu-west-2.amazonaws.com Deploy using Serverless Framework If you want to deploy all the resources for the EventBridge segment, please use the following resource: cd WebsocketSetup serverless deploy --region eu-west-2 And the above command would create the following services: 2 lambda functions - event_handler and message_publisher DynamoDB table to store and maintain connections WebSocket API","title":"WebSockets"},{"location":"WebSockets/#real-time-communication-using-websockets","text":"The application leverages WebSockets to create a tunnel between the UI/Client and the backend, using which messages can be transmitted by both parties, to both parties. This eliminates the need to refresh a page every time an update is received to the backend.","title":"Real Time Communication Using WebSockets"},{"location":"WebSockets/#architecture-details","text":"The notification service leverages the following AWS services: Amazon APIGateway\u2019s WebSocket API Lambda functions for connection management and message publishing DynamoDB to store & maintain all connections. The table has the following index configuration: connection_id as the partition key UserIdIndex as the Global Secondary Index with user_id as the partition key. This index is used to fetch the list of connections for a particular user_id","title":"Architecture Details"},{"location":"WebSockets/#understanding-notifications-service","text":"The notifications service consists of 2 parts: Connection management Publishing messages to the interested connections We can create routes for a WebSocket API (synonymous with API routes in REST API) and the RTC handler has the following routes: $connect - This route is called when the client is requesting to connect with the backend. The user_id is passed as a query param to be stored in the connection management DynamoDB table $disconnect - This route is called when the client disconnects from the backend. This is also called when the user navigates to a different page other than the scheduling page or when the tab is closed $default - This is the default route, called when the request is for a route that is not configured","title":"Understanding Notifications Service"},{"location":"WebSockets/#connection-management","text":"The client calls the WebSocket API with the $connect route and with the user_id passed in the query param. API Gateway will call the RTC Handler lambda with the $connect route with the connection_id . The lambda function stores the following information in DynamoDB: { \"connection_id\": \"M9aA1e3uvHcCH1A=\", \"user_id\": \"8a938091-7b1b-b753-017b-3f25f7540509\" } The client calls the $disconnect flow when the user navigates to a different page or the tab is closed. The lambda function just deletes the connectionId from the DynamoDB data store","title":"Connection Management"},{"location":"WebSockets/#sending-messages-to-the-client","text":"Messages can be sent to the connected clients using the WebSocket\u2019s connection URL and passing the connection_id to whom the message needs to be sent. The publisher lambda does the following: 1. Fetches the connection_id for the corresponding user_id 2. send the message using the AWS SDK for API Gateway, which leverages the connection_id and automatically sends the message","title":"Sending messages to the client"},{"location":"WebSockets/#factors-to-consider-while-using-websockets","text":"Cost - Websockets have a few factors considered for the pricing: We are charged for every minute a connection is kept alive The number of messages sent in the connection The connection timeouts, quotas, and limits: 500 connections per second Message Payload size: 128 KB Idle Connection Timeout - 10 minutes Connection duration for WebSocket API - 2 hours","title":"Factors to consider while using WebSockets"},{"location":"WebSockets/#steps-to-create-the-notifications-service","text":"The notifications service will be composed of 2 lambda functions: 1. event_handler - this lambda function is responsible for handling the connections - creating and deleting them from the connection-management DynamoDB table 2. message_publisher - this lambda function is responsible for sending messages to the client using the connection_id by leveraging the API Create the above 2 lambda functions using the console","title":"Steps to create the Notifications service"},{"location":"WebSockets/#steps-to-create-a-websocket-api","text":"Navigate to the API Gateway service on the AWS console and click on Create API , select Build under the WebSocket API section and provide the following details in each section: Step 1 (API Details) API Name - Name of the API we want to create. Ex: awesome-food-app Route selection expression - API Gateway uses the route selection expression to determine which route to invoke when a client sends a message. You can provide the standard $request.body.action Step 2 (Add Routes) - configure the list of routes you want to add for the API. You can just add the Predefined Routes : $connect - triggered when a client connects to your API $disconnect - triggered when either the server or the client closes the connection $default - triggered if the route selection expression can't be evaluated against the message or if no matching route is found and click on Next Step 3 (Attach Integrations) - this step is used to configure the target for the routes configured in the previous section. For every route configured, select the Integration Type as Lambda and provide the name of the notifications service lambda function name created above Step 4 (Add Stages) - configure stage name for your WebSocket API. Ex: dev Step 5 (Review & Create) - review all the configuration details and click on Create and Deploy if everything looks good","title":"Steps to create a WebSocket API"},{"location":"WebSockets/#steps-to-create-the-connection-management-dynamodb-table","text":"Navigate to the DynamoDB service on the AWS console and go to the Tables section and click on Create Table . Provide the table name connection-manager with connection_id as the partition key Select the default settings and click on Create Create a Global Secondary Index (GSI) by getting inside the specific table in the Tables/Update settings page: navigate to the Indexes tab. Click on Create Index Provide user_id and UserIdIndex as the index name Leave the rest of the settings as is and click on Create Index","title":"Steps to create the Connection Management DynamoDB table"},{"location":"WebSockets/#update-lambda-function-settings","text":"Update the IAM policy: Update the event_handler and message_publisher lambda function's permissions to provide access to DynamoDB (for connection management) and API Gateway to publish messages. You can update the lambda function's IAM role's policy to: { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"logs:CreateLogStream\", \"logs:CreateLogGroup\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" }, { \"Action\": [ \"logs:PutLogEvents\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" }, { \"Action\": [ \"dynamodb:Query\", \"dynamodb:GetItem\", \"dynamodb:PutItem\", \"dynamodb:UpdateItem\", \"dynamodb:DeleteItem\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" }, { \"Action\": [ \"execute-api:*\" ], \"Resource\": \"*\", \"Effect\": \"Allow\" } ] } Update the environment variables - Create an environment variable WEBSOCKET_DOMAIN for the lambda function and value can be fetched from the WebSocket API created in the above step. Ex: g107cr37nf.execute-api.eu-west-2.amazonaws.com","title":"Update Lambda function settings"},{"location":"WebSockets/#deploy-using-serverless-framework","text":"If you want to deploy all the resources for the EventBridge segment, please use the following resource: cd WebsocketSetup serverless deploy --region eu-west-2 And the above command would create the following services: 2 lambda functions - event_handler and message_publisher DynamoDB table to store and maintain connections WebSocket API","title":"Deploy using Serverless Framework"},{"location":"dynamodb/","text":"Upload data file foodorder.json to S3 bucket (e.g. imagesforwebsite) present in acd2022-serverless-workshop/DynamoDBSetup/ Now, to create a new table including the data in step-1, go the Dynamo DB Dashboard and choose \"imports from S3\" Provide the URI of file in Source: s3://imagesforwebsite/foodorder.json Provide Table name as: foodorder Define Partition Key: ID Define Sort Key: Type Create table using Default settings","title":"Dynamodb"},{"location":"uiIntegration/","text":"UI Integration After completing the API endpoints and the Cognito part on the backend, follow the steps for the integration in the UI - Setting up the UI Code base Navigate to GitHub and clone the repository Open the project in your code editor and a new terminal npm install (installs all the node modules) API and Cognito integration in the UI Go to axios.config.js in the src folder, replace the API and socket base url with your end point from the API segment Go to UserPool.js file in the src folder, replace the client_id and UserPoolId with yours from the Cognito segment npm run build on your terminal - It will optimize, compile, and dump the static files required to serve your application in a build directory. Deploy to S3 The application uses S3 bucket to deploy the web application. Deploying static files requires far fewer moving parts than an app with a server. There\u2019s less to set up and less to maintain. Because there\u2019s less to set up and maintain, the cost of deploying a static application can be dramatically cheaper. Create a new S3 bucket Create an account or sign in to the AWS Console Navigate to the S3 service and click on Create Bucket . Make up a clever name for your new bucket. In the Set Permissions step, deselect the options to block public access \u2014 we want users to access the website assets that will live here. Then go ahead and create the bucket. Click on the newly-created bucket. Within the Properties, open the Static Website Hosting tab, and select Use this bucket to host a static website - fill in index.html for both the Index and Error Documents. By setting index.html as the Error Document, we can allow something like react-router to handle routes outside of the root. Open the Permissions tab, then select Bucket Policy. You may choose to do something more nuanced here, but a good starting point is to provide read-only permissions for anonymous users \u2014 a policy provided in the AWS examples. Note - Make sure its your bucket name under the Resource key. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::your-bucket-name/*\" }, { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:PutObject\", \"Resource\": \"arn:aws:s3:::your-bucket-name/*\" }, { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:ListBucket\", \"Resource\": \"arn:aws:s3:::your-bucket-name\" } ] } Add the contents of your build directory to this bucket. This can be done by clicking on the bucket and clicking Upload. That\u2019s it! You can find the URL to your application back under the Static Website Hosting tab, labeled Endpoint. Bonus: Deploying with AWS CLI You can streamline the deployment process with the AWS Command Line Interface. For example, you might write an npm script to run tests, build the application and push to your S3 bucket. Briefly: Create a user with security credentials in IAM. Avoid providing more permissions than is necessary. Configure the CLI with aws configure. For example: AWS Access Key ID [None]: Your Access key AWS Secret Access Key [None]: Your Secret Access key Default region name [None]: us-west-2 Default output format [None]: json Deploy your app with the following command (using the bucket name) Note - If any changes are present in your local branch, build your app before you deploy, if not directly deploy it. // build and deploy the app npm run build && aws s3 sync build/ s3://your-bucket-name // deploy the app aws s3 sync build/ s3://your-bucket-name` The deploy script above is as simple as it gets. It takes the contents of the build directory (produced by npm run build) and replaces whatever is currently in your bucket with those contents. Deploy to CloudFront If it works on S3, why bother with CloudFront? CloudFront is the Content Delivery Network (CDN) service offered by AWS. CDNs optimize for speed by pushing your content out to edge locations, making it highly available around the globe. If your users are only local, the performance offered by S3 may be just fine. Follow the steps below Select theCloudFront service in the AWS console, click Create Distribution, then under the web delivery method, click Get Started. Select your Origin Settings. The Origin Domain Name choices pre-populate with S3 buckets. Selecting yours will also populate the Origin ID. Set the Default Root Object to index.html Click on Create Distribution Click the ID of your newly created distribution to reach its settings page, then click on the Error Pages tab. Select Create Custom Error Response. Select Yes for a custom error response, set/index.html for the response page path and 200: OK for the response code. This custom error page in the CloudFront distribution is analogous to the Error Document on the S3 bucket (and will work on IE, too). When done, click Create. That\u2019s it! Give the deployment a handful of minutes, then check out your web app. You can find the URL on the distribution listings page, under the Domain Name column.","title":"UI Integration"},{"location":"uiIntegration/#ui-integration","text":"After completing the API endpoints and the Cognito part on the backend, follow the steps for the integration in the UI -","title":"UI Integration"},{"location":"uiIntegration/#setting-up-the-ui-code-base","text":"Navigate to GitHub and clone the repository Open the project in your code editor and a new terminal npm install (installs all the node modules)","title":"Setting up the UI Code base"},{"location":"uiIntegration/#api-and-cognito-integration-in-the-ui","text":"Go to axios.config.js in the src folder, replace the API and socket base url with your end point from the API segment Go to UserPool.js file in the src folder, replace the client_id and UserPoolId with yours from the Cognito segment npm run build on your terminal - It will optimize, compile, and dump the static files required to serve your application in a build directory.","title":"API and Cognito integration in the UI"},{"location":"uiIntegration/#deploy-to-s3","text":"The application uses S3 bucket to deploy the web application. Deploying static files requires far fewer moving parts than an app with a server. There\u2019s less to set up and less to maintain. Because there\u2019s less to set up and maintain, the cost of deploying a static application can be dramatically cheaper.","title":"Deploy to S3"},{"location":"uiIntegration/#create-a-new-s3-bucket","text":"Create an account or sign in to the AWS Console Navigate to the S3 service and click on Create Bucket . Make up a clever name for your new bucket. In the Set Permissions step, deselect the options to block public access \u2014 we want users to access the website assets that will live here. Then go ahead and create the bucket. Click on the newly-created bucket. Within the Properties, open the Static Website Hosting tab, and select Use this bucket to host a static website - fill in index.html for both the Index and Error Documents. By setting index.html as the Error Document, we can allow something like react-router to handle routes outside of the root. Open the Permissions tab, then select Bucket Policy. You may choose to do something more nuanced here, but a good starting point is to provide read-only permissions for anonymous users \u2014 a policy provided in the AWS examples. Note - Make sure its your bucket name under the Resource key. { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:GetObject\", \"Resource\": \"arn:aws:s3:::your-bucket-name/*\" }, { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:PutObject\", \"Resource\": \"arn:aws:s3:::your-bucket-name/*\" }, { \"Effect\": \"Allow\", \"Principal\": \"*\", \"Action\": \"s3:ListBucket\", \"Resource\": \"arn:aws:s3:::your-bucket-name\" } ] } Add the contents of your build directory to this bucket. This can be done by clicking on the bucket and clicking Upload. That\u2019s it! You can find the URL to your application back under the Static Website Hosting tab, labeled Endpoint.","title":"Create a new S3 bucket"},{"location":"uiIntegration/#bonus-deploying-with-aws-cli","text":"You can streamline the deployment process with the AWS Command Line Interface. For example, you might write an npm script to run tests, build the application and push to your S3 bucket. Briefly: Create a user with security credentials in IAM. Avoid providing more permissions than is necessary. Configure the CLI with aws configure. For example: AWS Access Key ID [None]: Your Access key AWS Secret Access Key [None]: Your Secret Access key Default region name [None]: us-west-2 Default output format [None]: json Deploy your app with the following command (using the bucket name) Note - If any changes are present in your local branch, build your app before you deploy, if not directly deploy it. // build and deploy the app npm run build && aws s3 sync build/ s3://your-bucket-name // deploy the app aws s3 sync build/ s3://your-bucket-name` The deploy script above is as simple as it gets. It takes the contents of the build directory (produced by npm run build) and replaces whatever is currently in your bucket with those contents.","title":"Bonus: Deploying with AWS CLI"},{"location":"uiIntegration/#deploy-to-cloudfront","text":"If it works on S3, why bother with CloudFront? CloudFront is the Content Delivery Network (CDN) service offered by AWS. CDNs optimize for speed by pushing your content out to edge locations, making it highly available around the globe. If your users are only local, the performance offered by S3 may be just fine.","title":"Deploy to CloudFront"},{"location":"uiIntegration/#follow-the-steps-below","text":"Select theCloudFront service in the AWS console, click Create Distribution, then under the web delivery method, click Get Started. Select your Origin Settings. The Origin Domain Name choices pre-populate with S3 buckets. Selecting yours will also populate the Origin ID. Set the Default Root Object to index.html Click on Create Distribution Click the ID of your newly created distribution to reach its settings page, then click on the Error Pages tab. Select Create Custom Error Response. Select Yes for a custom error response, set/index.html for the response page path and 200: OK for the response code. This custom error page in the CloudFront distribution is analogous to the Error Document on the S3 bucket (and will work on IE, too). When done, click Create. That\u2019s it! Give the deployment a handful of minutes, then check out your web app. You can find the URL on the distribution listings page, under the Domain Name column.","title":"Follow the steps below"}]}