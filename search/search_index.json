{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Build your own Serverless Food Delivery App in 3 hours! Goal: Leverage AWS Serverless services to build a simple food delivery app in less than 3 hours! In this workshop, we will understand how easy & quick it is to build real-world applications using Serverless on AWS and understand the various services that can be leveraged. The application will present users with a React user interface for ordering food items. The interface on the backend with RESTful and WebSocket services will accept the request, and find and dispatch food to the requester\u2019s location. The application will also provide facilities for users to register with the service and log in before ordering food. Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Build your own Serverless Food Delivery App in 3 hours!"},{"location":"#build-your-own-serverless-food-delivery-app-in-3-hours","text":"Goal: Leverage AWS Serverless services to build a simple food delivery app in less than 3 hours! In this workshop, we will understand how easy & quick it is to build real-world applications using Serverless on AWS and understand the various services that can be leveraged. The application will present users with a React user interface for ordering food items. The interface on the backend with RESTful and WebSocket services will accept the request, and find and dispatch food to the requester\u2019s location. The application will also provide facilities for users to register with the service and log in before ordering food.","title":"Build your own Serverless Food Delivery App in 3 hours!"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"EventBridge/","text":"Setting up EventBridge","title":"EventBridge"},{"location":"EventBridge/#setting-up-eventbridge","text":"","title":"Setting up EventBridge"},{"location":"WebSockets/","text":"Real Time Communication Using WebSockets The application leverages WebSockets to create a tunnel between the UI/Client and the backend, using which messages can be transmitted by both parties, to both parties. This eliminates the need to refresh a page every time an update is received to the backend. Architecture Details TODO: add diagram The notification service leverages the following AWS services: Amazon APIGateway\u2019s WebSocket API Lambda functions for connection management and message publishing DynamoDB to store & maintain all connections. The table has the following index configuration: connection_id as the partition key UserIdIndex as the Global Secondary Index with user_id as the partition key. This index is used to fetch the list of connections for a particular user_id Understanding Notifications Service The notifications service consists of 2 parts: Connection management Publishing messages to the interested connections We can create routes for a WebSocket API (synonymous with API routes in REST API) and the RTC handler has the following routes: $connect - This route is called when the client is requesting to connect with the backend. The user_id is passed as a query param to be stored in the connection management DynamoDB table $disconnect - This route is called when the client disconnects from the backend. This is also called when the user navigates to a different page other than the scheduling page or when the tab is closed $default - This is the default route, called when the request is for a route that is not configured Connection Management The client calls the WebSocket API with the $connect route and with the user_id passed in the query param. API Gateway will call the RTC Handler lambda with the $connect route with the connection_id . The lambda function stores the following information in DynamoDB: { \"connection_id\": \"M9aA1e3uvHcCH1A=\", \"user_id\": \"8a938091-7b1b-b753-017b-3f25f7540509\" } The client calls the $disconnect flow when the user navigates to a different page or the tab is closed. The lambda function just deletes the connectionId from the DynamoDB data store Sending messages to the client Messages can be sent to the connected clients using the WebSocket\u2019s connection URL and passing the connection_id to whom the message needs to be sent. The publisher lambda does the following: 1. Fetches the connection_id for the corresponding user_id 2. send the message using the AWS SDK for API Gateway, which leverages the connection_id and automatically sends the message Factors to consider while using WebSockets Cost - Websockets have a few factors considered for the pricing: We are charged for every minute a connection is kept alive The number of messages sent in the connection The connection timeouts, quotas, and limits: 500 connections per second Message Payload size: 128 KB Idle Connection Timeout - 10 minutes Connection duration for WebSocket API - 2 hours Steps to create the Notifications service The notifications service will be composed of 2 lambda functions: 1. event_handler - this lambda function is responsible for handling the connections - creating and deleting them from the connection-management DynamoDB table 2. message_publisher - this lambda function is responsible for sending messages to the client using the connection_id by leveraging the API Steps to create a WebSocket API Navigate to the API Gateway service on the AWS console and click on Create API , select Build under the WebSocket API section and provide the following details in each section: Step 1 (API Details) API Name - Name of the API we want to create. Ex: awesome-food-app Route selection expression - API Gateway uses the route selection expression to determine which route to invoke when a client sends a message. You can provide the standard $request.body.action Step 2 (Add Routes) - configure the list of routes you want to add for the API. You can just add the Predefined Routes : $connect - triggered when a client connects to your API $disconnect - triggered when either the server or the client closes the connection $default - triggered if the route selection expression can't be evaluated against the message or if no matching route is found and click on Next Step 3 (Attach Integrations) - this step is used to configure the target for the routes configured in the previous section. For every route configured, select the Integration Type as Lambda and provide the name of the notifications service lambda function name created above Step 4 (Add Stages) - configure stage name for your WebSocket API. Ex: dev Step 5 (Review & Create) - review all the configuration details and click on Create and Deploy if everything looks good Once the API is created, you can del","title":"WebSockets"},{"location":"WebSockets/#real-time-communication-using-websockets","text":"The application leverages WebSockets to create a tunnel between the UI/Client and the backend, using which messages can be transmitted by both parties, to both parties. This eliminates the need to refresh a page every time an update is received to the backend.","title":"Real Time Communication Using WebSockets"},{"location":"WebSockets/#architecture-details","text":"TODO: add diagram The notification service leverages the following AWS services: Amazon APIGateway\u2019s WebSocket API Lambda functions for connection management and message publishing DynamoDB to store & maintain all connections. The table has the following index configuration: connection_id as the partition key UserIdIndex as the Global Secondary Index with user_id as the partition key. This index is used to fetch the list of connections for a particular user_id","title":"Architecture Details"},{"location":"WebSockets/#understanding-notifications-service","text":"The notifications service consists of 2 parts: Connection management Publishing messages to the interested connections We can create routes for a WebSocket API (synonymous with API routes in REST API) and the RTC handler has the following routes: $connect - This route is called when the client is requesting to connect with the backend. The user_id is passed as a query param to be stored in the connection management DynamoDB table $disconnect - This route is called when the client disconnects from the backend. This is also called when the user navigates to a different page other than the scheduling page or when the tab is closed $default - This is the default route, called when the request is for a route that is not configured","title":"Understanding Notifications Service"},{"location":"WebSockets/#connection-management","text":"The client calls the WebSocket API with the $connect route and with the user_id passed in the query param. API Gateway will call the RTC Handler lambda with the $connect route with the connection_id . The lambda function stores the following information in DynamoDB: { \"connection_id\": \"M9aA1e3uvHcCH1A=\", \"user_id\": \"8a938091-7b1b-b753-017b-3f25f7540509\" } The client calls the $disconnect flow when the user navigates to a different page or the tab is closed. The lambda function just deletes the connectionId from the DynamoDB data store","title":"Connection Management"},{"location":"WebSockets/#sending-messages-to-the-client","text":"Messages can be sent to the connected clients using the WebSocket\u2019s connection URL and passing the connection_id to whom the message needs to be sent. The publisher lambda does the following: 1. Fetches the connection_id for the corresponding user_id 2. send the message using the AWS SDK for API Gateway, which leverages the connection_id and automatically sends the message","title":"Sending messages to the client"},{"location":"WebSockets/#factors-to-consider-while-using-websockets","text":"Cost - Websockets have a few factors considered for the pricing: We are charged for every minute a connection is kept alive The number of messages sent in the connection The connection timeouts, quotas, and limits: 500 connections per second Message Payload size: 128 KB Idle Connection Timeout - 10 minutes Connection duration for WebSocket API - 2 hours","title":"Factors to consider while using WebSockets"},{"location":"WebSockets/#steps-to-create-the-notifications-service","text":"The notifications service will be composed of 2 lambda functions: 1. event_handler - this lambda function is responsible for handling the connections - creating and deleting them from the connection-management DynamoDB table 2. message_publisher - this lambda function is responsible for sending messages to the client using the connection_id by leveraging the API","title":"Steps to create the Notifications service"},{"location":"WebSockets/#steps-to-create-a-websocket-api","text":"Navigate to the API Gateway service on the AWS console and click on Create API , select Build under the WebSocket API section and provide the following details in each section: Step 1 (API Details) API Name - Name of the API we want to create. Ex: awesome-food-app Route selection expression - API Gateway uses the route selection expression to determine which route to invoke when a client sends a message. You can provide the standard $request.body.action Step 2 (Add Routes) - configure the list of routes you want to add for the API. You can just add the Predefined Routes : $connect - triggered when a client connects to your API $disconnect - triggered when either the server or the client closes the connection $default - triggered if the route selection expression can't be evaluated against the message or if no matching route is found and click on Next Step 3 (Attach Integrations) - this step is used to configure the target for the routes configured in the previous section. For every route configured, select the Integration Type as Lambda and provide the name of the notifications service lambda function name created above Step 4 (Add Stages) - configure stage name for your WebSocket API. Ex: dev Step 5 (Review & Create) - review all the configuration details and click on Create and Deploy if everything looks good Once the API is created, you can del","title":"Steps to create a WebSocket API"},{"location":"dynamodb/","text":"/b jfjkhfjk","title":"Dynamodb"}]}